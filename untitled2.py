# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UoVXhFWbCt2rcSdemUwFWT72lWuEPu_s
"""

import streamlit as st
import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error

def root_mean_squared_error(y_true, y_pred):
    return np.sqrt(mean_squared_error(y_true, y_pred))

def train_model(train_data):
    """Train a linear regression model using the training data."""
    # Split data into numerical and categorical columns
    numcols = train_data[['temp', 'atemp', 'hum', 'windspeed', 'casual', 'registered', 'cnt']]
    objcols = train_data[['season', 'yr', 'mnth', 'hr', 'holiday', 'weekday', 'workingday', 'weathersit']]

    # Dummy encode categorical columns
    objcols_dummy = pd.get_dummies(objcols, columns=['season', 'yr', 'mnth', 'hr', 'holiday', 'weekday', 'workingday', 'weathersit'])

    # Combine numerical and dummy-encoded columns
    bikedf_final = pd.concat([numcols, objcols_dummy], axis=1)

    # Split data into features (X) and target (y)
    y = bikedf_final['cnt']
    X = bikedf_final.drop('cnt', axis=1)

    # Drop multicollinear columns
    X_new = X.drop(['atemp', 'registered'], axis=1)

    # Train the linear regression model
    regmodel_new = LinearRegression().fit(X_new, y)

    # Predict and calculate metrics
    regmodel_new_pred = regmodel_new.predict(X_new)
    r_squared = regmodel_new.score(X_new, y)
    rmse = root_mean_squared_error(y, regmodel_new_pred)

    return regmodel_new, X_new.columns, r_squared, rmse

def evaluate_model(model, X_cols, test_data):
    """Evaluate the model using the test data."""
    # Prepare test data
    test_numcols = test_data[['temp', 'atemp', 'hum', 'windspeed', 'casual', 'registered', 'cnt']]
    test_objcols = test_data[['season', 'yr', 'mnth', 'hr', 'holiday', 'weekday', 'workingday', 'weathersit']]

    test_objcols_dummy = pd.get_dummies(test_objcols, columns=['season', 'yr', 'mnth', 'hr', 'holiday', 'weekday', 'workingday', 'weathersit'])
    test_final = pd.concat([test_numcols, test_objcols_dummy], axis=1)

    # Align columns with training data
    X_test = test_final[X_cols]
    y_test = test_final['cnt']

    # Predict and calculate RMSE
    y_test_pred = model.predict(X_test)
    test_rmse = root_mean_squared_error(y_test, y_test_pred)

    return test_rmse

# Streamlit app
st.title("Bike Sharing Demand Prediction")

# Upload training data
st.header("Step 1: Upload Training Data")
train_file = st.file_uploader("Upload training data (CSV format)", type=['csv'])
if train_file is not None:
    train_data = pd.read_csv(train_file)
    st.write("Training Data Preview:", train_data.head())

    model, X_cols, r_squared, train_rmse = train_model(train_data)

    st.subheader("Training Results")
    st.write(f"R-squared: {r_squared:.4f}")
    st.write(f"RMSE (Training): {train_rmse:.4f}")

    # Upload test data
    st.header("Step 2: Upload Test Data")
    test_file = st.file_uploader("Upload test data (CSV format)", type=['csv'])
    if test_file is not None:
        test_data = pd.read_csv(test_file)
        st.write("Test Data Preview:", test_data.head())

        test_rmse = evaluate_model(model, X_cols, test_data)

        st.subheader("Test Results")
        st.write(f"RMSE (Test): {test_rmse:.4f}")